/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 *
 * Based on the original sources
 *   Faery Tale II -- The Halls of the Dead
 *   (c) 1993-1996 The Wyrmkeep Entertainment Co.
 */

#ifndef SAGA2_MESSAGER_H
#define SAGA2_MESSAGER_H

#include "saga2/vdraw.h"
#include "saga2/grequest.h"
#include "saga2/winini.h"
#include "saga2/mono.h"

namespace Saga2 {

// max filename length
#define MAX_LOG_NAME_LENGTH 260

/****** messager.cpp/Messager [class] *******************************
*
*   NAME
*       Messager [class] -- classes for handling text messages
*
*   FUNCTION
*       The Messager classes are intended to handle text messages
*       generated by the program. Debugging text, status lines,
*       warning and error messages, and log files are some of the
*       implementations of these classes.
*
*
*
*
*   SEE ALSO
*       gError [class]
*
*******************************************************************/

//-------------------------------------------------------------------
// This is the base messager class
//   Note the constructor which takes a string argument. Most of the
//     Messager classes can be enabled based on the value of an
//     entry in the INI file.
//   Carriage returns are automatically appended to lines that don't
//     already have them.

class Messager {
protected:
	bool enabled;
	virtual int dumpit(char *, size_t) = 0;

public:
	Messager() {
		enabled = TRUE;
	}
	Messager(char *entry) {
		enabled = GetPrivateProfileInt("Debug", entry, FALSE, iniFile);
	}
	virtual ~Messager() {}

	size_t operator()(char *format, ...);
	size_t va(char *format, va_list argptr);

	void enable() {
		enabled = TRUE;
	}
	void disable() {
		enabled = FALSE;
	}
	bool active() {
		return enabled;
	}
};

typedef Messager *pMessager;

//-------------------------------------------------------------------
// Tee Messager

#define MAX_MESSAGER_TEES 4

class TeeMessager : public Messager {
private:
	int16 numSplit;
	pMessager mSub[MAX_MESSAGER_TEES];

protected:
	int dumpit(char *, size_t);

public:
	TeeMessager(pMessager, pMessager);
	TeeMessager(pMessager, pMessager, pMessager);
	TeeMessager(pMessager, pMessager, pMessager, pMessager);
	~TeeMessager() {}
};


//-------------------------------------------------------------------
// Messager that ignores text

class NullMessager : public Messager {
protected:
	int dumpit(char *, size_t) {
		return 0;
	}

public:
	NullMessager() {
		enabled = FALSE;
	}
	~NullMessager() {}

};

//-------------------------------------------------------------------
// Messager to write text to a log file. Has several options:
//   A maximum size for the log file can be given
//   Normally any existing log is deleted. This can be overridden

class FastLogMessager : public Messager {
private:
	char logFileName[MAX_LOG_NAME_LENGTH];
	FILE *logFile;
	size_t maxSize;
	uint32 flags;

protected:
	int dumpit(char *s, size_t size) ;

public:
	enum logOpenFlags {
		logOpenNormal = 0,
		logOpenAppend = 1 << 0,
		logTimeStamp  = 1 << 1,
	};

	FastLogMessager(char *filename, size_t sizeLimit = 0, logOpenFlags flgs = logOpenNormal);
	FastLogMessager(char *entry, char *filename, size_t sizeLimit = 0, logOpenFlags flgs = logOpenNormal);
	~FastLogMessager();
};

//-------------------------------------------------------------------
// Similar to the FastLogMessager, but the file is kept closed most of
//   the time. While this is noteicably slower, the log will actually
//   be there after a crash.

class SureLogMessager : public Messager {
private:
	char logFileName[MAX_LOG_NAME_LENGTH];
	size_t maxSize;
	uint32 flags;

protected:
	int dumpit(char *s, size_t size) ;

public:
	enum logOpenFlags {
		logOpenNormal = 0,
		logOpenAppend = 1 << 0,
		logTimeStamp  = 1 << 1,
	};

	SureLogMessager(char *filename, size_t sizeLimit = 0, logOpenFlags flgs = logOpenNormal);
	SureLogMessager(char *entry, char *filename, size_t sizeLimit = 0, logOpenFlags flgs = logOpenNormal);
	~SureLogMessager();
};

//-------------------------------------------------------------------
// This Messager acts like the gError::warn() routine. Text is appended
//   to an internal buffer till the Messager is destroyed. At that
//   point the entire buffer is written to stderr. The buffer is
//   internally allocated, but you need to specify how big to make it
//   in the constructor.

class BufferedTextMessager : public Messager {
protected:
	char *dumpText;
	size_t bufSiz, bufPos;

	int dumpit(char *, size_t);

public:
	BufferedTextMessager(size_t s);
	BufferedTextMessager(char *entry, size_t s);
	~BufferedTextMessager();
};

//-------------------------------------------------------------------
// This messager writes text on a gDisplayPort (usually mainPort).
//   If you have seen the debugging lines in FTA2, this class acts
//   like a single one of those lines. Generally you will have several
//   of these. By default the lines will be in the lower right corner,
//   but you can specify any location you like. The positions of
//   multiple lines are automatically accounted for.

class StatusLineMessager : public Messager {
private:
	int line;
	int32 atX, atY, atW;
	int16 atColor;
	gDisplayPort *textPort;

protected:
	int dumpit(char *s, size_t size) ;

public:
	StatusLineMessager(int line, gDisplayPort *mp, int32 x = -1, int32 y = -1, int32 w = -1, int16 color = -1);
	StatusLineMessager(char *entry, int line, gDisplayPort *mp, int32 x = -1, int32 y = -1, int32 w = -1, int16 color = -1);
	~StatusLineMessager();
};

//-------------------------------------------------------------------
// This Messager should pop up a modal dialog with the text on it.
//   While this is easily done in Windows, or with gTools, FTA2 for
//   DOS doesn't have that capability yet, so its not fully functional

class DialogMessager : public Messager {
private:
	char header[32];
	int dummy_va_arg_dump(char *s, ...);

protected:
	int dumpit(char *s, size_t size);

public:
	DialogMessager(char *head);
	DialogMessager(char *entry, char *head);
	~DialogMessager();
};


//-------------------------------------------------------------------
// If you have DEBRK.LIB set up this class will dump text to the
//   Log window of the Watcom Debugger. If you don't or if you're
//   using Windows, this is effectively a NullMessager

class DebuggerMessager : public Messager {
protected:
#if defined(__WATCOMC__)
#if DEBUG
	int dumpit(char *s, size_t l) {
		DEBUG_DUMP(s);
		return l;
	}
#else
	int dumpit(char *, size_t l) {
		return l;
	}
#endif
#else
#if DEBUG
	int dumpit(char *s, size_t l) {
		OutputDebugString(s);
		return l;
	}
#else
	int dumpit(char *, size_t l) {
		return l;
	}
#endif
#endif

public:
	DebuggerMessager() {}
	DebuggerMessager(char *entry) : Messager(entry) {}
	~DebuggerMessager() {}
};

//-------------------------------------------------------------------
// These use Robert McNally's Mono code to dump to the mono screen

class MonoMessager : public Messager {
protected:
	int dumpit(char *s, size_t size);

public:
	MonoMessager(void);
	MonoMessager(char *entry);
	~MonoMessager();
};

} // end of namespace Saga2

#endif
