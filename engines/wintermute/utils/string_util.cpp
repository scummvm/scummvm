/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

/*
 * This file is based on WME Lite.
 * http://dead-code.org/redir.php?target=wmelite
 * Copyright (c) 2011 Jan Nedoma
 */

#include "common/language.h"
#include "common/tokenizer.h"
#include "engines/wintermute/base/base_engine.h"
#include "engines/wintermute/utils/string_util.h"
#include "engines/wintermute/utils/convert_utf.h"

namespace Wintermute {

//////////////////////////////////////////////////////////////////////////
bool StringUtil::compareNoCase(const AnsiString &str1, const AnsiString &str2) {
	return (str1.compareToIgnoreCase(str2) == 0);
}

//////////////////////////////////////////////////////////////////////////
/*bool StringUtil::CompareNoCase(const WideString &str1, const WideString &str2) {
    WideString str1lc = str1;
    WideString str2lc = str2;

    ToLowerCase(str1lc);
    ToLowerCase(str2lc);

    return (str1lc == str2lc);
}*/

//////////////////////////////////////////////////////////////////////////
WideString StringUtil::utf8ToWide(const Utf8String &Utf8Str) {
	size_t wideSize = Utf8Str.size();

	uint32 *wideStringNative = new uint32[wideSize + 1];

	const UTF8 *sourceStart = reinterpret_cast<const UTF8 *>(Utf8Str.c_str());
	const UTF8 *sourceEnd = sourceStart + wideSize;

	UTF32 *targetStart = reinterpret_cast<UTF32 *>(wideStringNative);
	UTF32 *targetEnd = targetStart + wideSize;

	ConversionResult res = ConvertUTF8toUTF32(&sourceStart, sourceEnd, &targetStart, targetEnd, strictConversion);
	if (res != conversionOK) {
		delete[] wideStringNative;
		return WideString();
	}
	*targetStart = 0;
	WideString resultString(wideStringNative);
	delete[] wideStringNative;
	return resultString;
}

//////////////////////////////////////////////////////////////////////////
Utf8String StringUtil::wideToUtf8(const WideString &WideStr) {
	size_t wideSize = WideStr.size();

	size_t utf8Size = 4 * wideSize + 1;
	char *utf8StringNative = new char[utf8Size];

	const UTF32 *sourceStart = reinterpret_cast<const UTF32 *>(WideStr.c_str());
	const UTF32 *sourceEnd = sourceStart + wideSize;

	UTF8 *targetStart = reinterpret_cast<UTF8 *>(utf8StringNative);
	UTF8 *targetEnd = targetStart + utf8Size;

	ConversionResult res = ConvertUTF32toUTF8(&sourceStart, sourceEnd, &targetStart, targetEnd, strictConversion);
	if (res != conversionOK) {
		delete[] utf8StringNative;
		return Utf8String();
	}
	*targetStart = 0;
	Utf8String resultString(utf8StringNative);
	delete[] utf8StringNative;
	return resultString;
}

//////////////////////////////////////////////////////////////////////////
uint32* StringUtil::getCharsetTable(TTextCharset charset) {
	switch (charset) {
	case CHARSET_ANSI:
		return _ansiToUTF32;

	case CHARSET_EASTEUROPE:
		return _cp1250ToUTF32;

	case CHARSET_RUSSIAN:
		return _cp1251ToUTF32;

	case CHARSET_GREEK:
		return _cp1253ToUTF32;

	case CHARSET_HEBREW:
		return _cp1255ToUTF32;

	case CHARSET_BALTIC:
		return _cp1257ToUTF32;

	case CHARSET_DEFAULT:
		switch (BaseEngine::instance().getLanguage()) {

		//cp1250: Central Europe
		case Common::CZ_CZE:
		case Common::HR_HRV:
		case Common::HU_HUN:
		case Common::PL_POL:
		case Common::SK_SVK:
			return _cp1250ToUTF32;

		//cp1251: Cyrillic
		case Common::RU_RUS:
		case Common::UA_UKR:
			return _cp1251ToUTF32;

		//cp1252: Western Europe
		case Common::DA_DAN:
		case Common::DE_DEU:
		case Common::EN_ANY:
		case Common::EN_GRB:
		case Common::EN_USA:
		case Common::ES_ESP:
		case Common::FI_FIN:
		case Common::FR_FRA:
		case Common::IT_ITA:
		case Common::NB_NOR:
		case Common::NL_NLD:
		case Common::PT_BRA:
		case Common::PT_POR:
		case Common::SE_SWE:
		case Common::UNK_LANG:
			return _ansiToUTF32;

		//cp1253: Greek
		case Common::GR_GRE:
			return _cp1253ToUTF32;

		//cp1255: Hebrew
		case Common::HE_ISR:
			return _cp1255ToUTF32;

		//cp1257: Baltic
		case Common::ET_EST:
		case Common::LV_LAT:
			return _cp1257ToUTF32;

		default:
			return _ansiToUTF32;
		}

	case CHARSET_OEM:
	case CHARSET_CHINESEBIG5:
	case CHARSET_GB2312:
	case CHARSET_HANGUL:
	case CHARSET_MAC:
	case CHARSET_SHIFTJIS:
	case CHARSET_SYMBOL:
	case CHARSET_TURKISH:
	case CHARSET_VIETNAMESE:
	case CHARSET_JOHAB:
	case CHARSET_ARABIC:
	case CHARSET_THAI:
	default:
		warning("Unsupported charset: %d", charset);
		return _ansiToUTF32;
	}
}

//////////////////////////////////////////////////////////////////////////
WideString StringUtil::ansiToWide(const AnsiString &str, TTextCharset charset) {
	WideString result;
	uint32 *charsetToUTF32 = getCharsetTable(charset);
	for (AnsiString::const_iterator i = str.begin(), end = str.end(); i != end; ++i) {
		const byte c = *i;
		if (c < 0x80 || (c >= 0xA0 && charsetToUTF32 == _ansiToUTF32)) {
			result += c;
		} else {
			uint32 utf32 = charsetToUTF32[c - 0x80];
			if (utf32) {
				result += utf32;
			} else {
				// It's an invalid CP125X character...
			}
		}
	}
	return result;
}

//////////////////////////////////////////////////////////////////////////
AnsiString StringUtil::wideToAnsi(const WideString &wstr, TTextCharset charset) {
	AnsiString result;
	uint32 *charsetToUTF32 = getCharsetTable(charset);
	uint charsetLen = (charsetToUTF32 == _ansiToUTF32) ? ARRAYSIZE(_ansiToUTF32) : 128;
	for (WideString::const_iterator i = wstr.begin(), end = wstr.end(); i != end; ++i) {
		const uint32 c = *i;
		if (c < 0x80 || (c >= 0xA0 && c <= 0xFF && charsetToUTF32 == _ansiToUTF32)) {
			result += c;
		} else {
			uint32 ansi = 0xFFFFFFFF;
			for (uint j = 0; j < charsetLen; ++j) {
				if (charsetToUTF32[j] == c) {
					ansi = j + 0x80;
					break;
				}
			}

			if (ansi != 0xFFFFFFFF) {
				result += ansi;
			} else {
				// There's no valid CP1252 code for this character...
			}
		}
	}
	return result;
}

//////////////////////////////////////////////////////////////////////////
bool StringUtil::isUtf8BOM(const byte *buffer, uint32 bufferSize) {
	if (bufferSize > 3 && buffer[0] == 0xEF && buffer[1] == 0xBB && buffer[2] == 0xBF) {
		return true;
	} else {
		return false;
	}
}

//////////////////////////////////////////////////////////////////////////
int StringUtil::indexOf(const WideString &str, const WideString &toFind, size_t startFrom) {
	return str.find(toFind, startFrom);
}

Common::String StringUtil::encodeSetting(const Common::String &str) {
	for (uint32 i = 0; i < str.size(); i++) {
		if ((str[i] < 33) || (str[i] == '=') || (str[i] > 126)) {
			error("Setting contains illegal characters: %s", str.c_str());
		}
	}
	return str;
}

Common::String StringUtil::decodeSetting(const Common::String &str) {
	return str;
}

//////////////////////////////////////////////////////////////////////////
AnsiString StringUtil::toString(int val) {
	return Common::String::format("%d", val);
}

// Mapping of CP1252 characters 0x80...0x9F into UTF-32
uint32 StringUtil::_ansiToUTF32[32] = {
	0x20AC, 0x0000, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021, 0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x0000, 0x017D, 0x0000,
	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014, 0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x0000, 0x017E, 0x0178
};

// Mapping of CP1250 characters 0x80...0xFF into UTF-32
uint32 StringUtil::_cp1250ToUTF32[128] = {
	0x20AC, 0x0000, 0x201A, 0x0000, 0x201E, 0x2026, 0x2020, 0x2021, 0x0000, 0x2030, 0x0160, 0x2039, 0x015A, 0x0164, 0x017D, 0x0179, 
	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014, 0x0000, 0x2122, 0x0161, 0x203A, 0x015B, 0x0165, 0x017E, 0x017A, 
	0x00A0, 0x02C7, 0x02D8, 0x0141, 0x00A4, 0x0104, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x015E, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x017B, 
	0x00B0, 0x00B1, 0x02DB, 0x0142, 0x00B4, 0x00B5, 0x00B6, 0x00B7, 0x00B8, 0x0105, 0x015F, 0x00BB, 0x013D, 0x02DD, 0x013E, 0x017C, 
	0x0154, 0x00C1, 0x00C2, 0x0102, 0x00C4, 0x0139, 0x0106, 0x00C7, 0x010C, 0x00C9, 0x0118, 0x00CB, 0x011A, 0x00CD, 0x00CE, 0x010E, 
	0x0110, 0x0143, 0x0147, 0x00D3, 0x00D4, 0x0150, 0x00D6, 0x00D7, 0x0158, 0x016E, 0x00DA, 0x0170, 0x00DC, 0x00DD, 0x0162, 0x00DF, 
	0x0155, 0x00E1, 0x00E2, 0x0103, 0x00E4, 0x013A, 0x0107, 0x00E7, 0x010D, 0x00E9, 0x0119, 0x00EB, 0x011B, 0x00ED, 0x00EE, 0x010F, 
	0x0111, 0x0144, 0x0148, 0x00F3, 0x00F4, 0x0151, 0x00F6, 0x00F7, 0x0159, 0x016F, 0x00FA, 0x0171, 0x00FC, 0x00FD, 0x0163, 0x02D9
};

// Mapping of CP1251 characters 0x80...0xFF into UTF-32
uint32 StringUtil::_cp1251ToUTF32[128] = {
	0x0402, 0x0403, 0x201A, 0x0453, 0x201E, 0x2026, 0x2020, 0x2021, 0x20AC, 0x2030, 0x0409, 0x2039, 0x040A, 0x040C, 0x040B, 0x040F,
	0x0452, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014, 0x0000, 0x2122, 0x0459, 0x203A, 0x045A, 0x045C, 0x045B, 0x045F,
	0x00A0, 0x040E, 0x045E, 0x0408, 0x00A4, 0x0490, 0x00A6, 0x00A7, 0x0401, 0x00A9, 0x0404, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x0407,
	0x00B0, 0x00B1, 0x0406, 0x0456, 0x0491, 0x00B5, 0x00B6, 0x00B7, 0x0451, 0x2116, 0x0454, 0x00BB, 0x0458, 0x0405, 0x0455, 0x0457,
	0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F,
	0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F,
	0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437, 0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
	0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, 0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F
};

// Mapping of CP1253 characters 0x80...0xFF into UTF-32
uint32 StringUtil::_cp1253ToUTF32[128] = {
	0x20AC, 0x0000, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021, 0x0000, 0x2030, 0x0000, 0x2039, 0x0000, 0x0000, 0x0000, 0x0000, 
	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014, 0x0000, 0x2122, 0x0000, 0x203A, 0x0000, 0x0000, 0x0000, 0x0000, 
	0x00A0, 0x0385, 0x0386, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x0000, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x2015, 
	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x0384, 0x00B5, 0x00B6, 0x00B7, 0x0388, 0x0389, 0x038A, 0x00BB, 0x038C, 0x00BD, 0x038E, 0x038F, 
	0x0390, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397, 0x0398, 0x0399, 0x039A, 0x039B, 0x039C, 0x039D, 0x039E, 0x039F, 
	0x03A0, 0x03A1, 0x0000, 0x03A3, 0x03A4, 0x03A5, 0x03A6, 0x03A7, 0x03A8, 0x03A9, 0x03AA, 0x03AB, 0x03AC, 0x03AD, 0x03AE, 0x03AF, 
	0x03B0, 0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7, 0x03B8, 0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF, 
	0x03C0, 0x03C1, 0x03C2, 0x03C3, 0x03C4, 0x03C5, 0x03C6, 0x03C7, 0x03C8, 0x03C9, 0x03CA, 0x03CB, 0x03CC, 0x03CD, 0x03CE, 0x0000
};

// Mapping of CP1255 characters 0x80...0xFF into UTF-32
uint32 StringUtil::_cp1255ToUTF32[128] = {
	0x20AC, 0x0000, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021, 0x02C6, 0x2030, 0x0000, 0x2039, 0x0000, 0x0000, 0x0000, 0x0000, 
	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014, 0x02DC, 0x2122, 0x0000, 0x203A, 0x0000, 0x0000, 0x0000, 0x0000, 
	0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x20AA, 0x00A5, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x00D7, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF, 
	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, 0x00B8, 0x00B9, 0x00F7, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF, 
	0x05B0, 0x05B1, 0x05B2, 0x05B3, 0x05B4, 0x05B5, 0x05B6, 0x05B7, 0x05B8, 0x05B9, 0x0000, 0x05BB, 0x05BC, 0x05BD, 0x05BE, 0x05BF, 
	0x05C0, 0x05C1, 0x05C2, 0x05C3, 0x05F0, 0x05F1, 0x05F2, 0x05F3, 0x05F4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
	0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7, 0x05D8, 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF, 
	0x05E0, 0x05E1, 0x05E2, 0x05E3, 0x05E4, 0x05E5, 0x05E6, 0x05E7, 0x05E8, 0x05E9, 0x05EA, 0x0000, 0x0000, 0x200E, 0x200F, 0x0000
};

// Mapping of CP1257 characters 0x80...0xFF into UTF-32
uint32 StringUtil::_cp1257ToUTF32[128] = {
	0x20AC, 0x0000, 0x201A, 0x0000, 0x201E, 0x2026, 0x2020, 0x2021, 0x0000, 0x2030, 0x0000, 0x2039, 0x0000, 0x00A8, 0x02C7, 0x00B8, 
	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014, 0x0000, 0x2122, 0x0000, 0x203A, 0x0000, 0x00AF, 0x02DB, 0x0000, 
	0x00A0, 0x0000, 0x00A2, 0x00A3, 0x00A4, 0x0000, 0x00A6, 0x00A7, 0x00D8, 0x00A9, 0x0156, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00C6, 
	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, 0x00F8, 0x00B9, 0x0157, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00E6, 
	0x0104, 0x012E, 0x0100, 0x0106, 0x00C4, 0x00C5, 0x0118, 0x0112, 0x010C, 0x00C9, 0x0179, 0x0116, 0x0122, 0x0136, 0x012A, 0x013B, 
	0x0160, 0x0143, 0x0145, 0x00D3, 0x014C, 0x00D5, 0x00D6, 0x00D7, 0x0172, 0x0141, 0x015A, 0x016A, 0x00DC, 0x017B, 0x017D, 0x00DF, 
	0x0105, 0x012F, 0x0101, 0x0107, 0x00E4, 0x00E5, 0x0119, 0x0113, 0x010D, 0x00E9, 0x017A, 0x0117, 0x0123, 0x0137, 0x012B, 0x013C, 
	0x0161, 0x0144, 0x0146, 0x00F3, 0x014D, 0x00F5, 0x00F6, 0x00F7, 0x0173, 0x0142, 0x015B, 0x016B, 0x00FC, 0x017C, 0x017E, 0x02D9, 
};

} // End of namespace Wintermute
